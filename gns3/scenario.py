from collections import namedtuple
from typing import Any, List, Dict, Optional, Pattern
import configparser
import ipaddress
import json
import os
import re
import resource
import time
import requests
import warnings

PROJECT_NAME = "iot_anomaly_detection_2"

Server = namedtuple("Server", ("addr", "port", "auth", "user", "password"))
Project = namedtuple("Project", ("name", "id", "grid_unit"))
Item = namedtuple("Item", ("name", "id"))


def check_resources() -> None:
    nofile_soft, nofile_hard = resource.getrlimit(resource.RLIMIT_NOFILE)
    if nofile_soft <= 1024:
        msg = (
            f"The maximum number of open file descriptors for the current process is set to {nofile_soft}.\n"
            "This limit might not be enough to run multiple devices in GNS3 (approx more than 150 docker devices, may vary).\n"
            "To increase the limit, edit '/etc/security/limits.conf' and append: \n"
            "*                hard    nofile          65536\n"
            "*                soft    nofile          65536\n"
        )
        warnings.warn(msg, RuntimeWarning)


def read_local_gns3_config():
    config = configparser.ConfigParser()
    with open(os.path.expanduser("~/.config/GNS3/2.2/gns3_server.conf")) as f:
        config.read_file(f)
    return config["Server"].get("host"), config["Server"].getint("port"), config["Server"].getboolean("auth"), config["Server"].get("user"), config["Server"].get("password")


def get_static_interface_config_file(iface: str, address: str, netmask: str, gateway: str) -> str:
    return (
        "# autogenerated\n"
        f"# Static config for {iface}\n"
        f"auto {iface}\n"
        f"iface {iface} inet static\n"
        f"\taddress {address}\n"
        f"\tnetmask {netmask}\n"
        f"\tgateway {gateway}\n"
        f"\tup echo nameserver {gateway} > /etc/resolv.conf\n"
    )


def template_id_from_name(template: List[Dict[str, Any]], name: str) -> Optional[str]:
    for d in template:
        if d["name"] == name:
            return d["template_id"]


def get_nodes_id_by_name_regexp(server: Server, project: Project, name_regexp: Pattern) -> Optional[List[Item]]:
    r = requests.get(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/nodes", auth=(server.user, server.password))
    r.raise_for_status()
    nodes: List[Dict[str, Any]] = r.json()
    nodes_filtered = list(filter(lambda n: name_regexp.match(n["name"]), nodes))
    return [Item(n["name"], n["node_id"]) for n in nodes_filtered]


def get_links_id_from_node_connected_to_name_regexp(server: Server, project: Project, node_id: str, name_regexp: Pattern) -> Optional[List[Item]]:
    r = requests.get(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/nodes/{node_id}", auth=(server.user, server.password))
    r.raise_for_status()
    node_name = r.json()["name"]

    r = requests.get(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/nodes/{node_id}/links", auth=(server.user, server.password))
    r.raise_for_status()
    links = r.json()
    relevant_nodes = get_nodes_id_by_name_regexp(server, project, name_regexp)

    def is_link_relevant(link: Dict) -> Optional[Item]:
        for c in link["nodes"]: # two ends of the link
            for rn in relevant_nodes:
                if c["node_id"] == rn.id:
                    return rn
        return None

    links_filtered: List[Item]= []
    for link in links:
        linked_node = is_link_relevant(link)
        if linked_node:
            links_filtered.append(Item(f"{linked_node.name} <--> {node_name}", link["link_id"]))

    return links_filtered


def start_node(server: Server, project: Project, node_id: str) -> None:
    r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/nodes/{node_id}/start", data={}, auth=(server.user, server.password))
    r.raise_for_status()


def stop_node(server: Server, project: Project, node_id: str) -> None:
    r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/nodes/{node_id}/stop", data={}, auth=(server.user, server.password))
    r.raise_for_status()


def delete_node(server: Server, project: Project, node_id: str) -> None:
    # check if node is running?
    r = requests.delete(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/nodes/{node_id}", auth=(server.user, server.password))
    r.raise_for_status()


def create_cluster_of_devices(server, project, num_devices, start_x, start_y, switch_template_id, device_template_id, start_ip, devices_per_row=10):
    assert num_devices < 64  # parece que el switch por defecto no puede tener mas de 64 interfaces activas. Error while creating link: Dynamips error when running command ...
    # create cluster switch
    payload = {"x": start_x + int(devices_per_row/2)*project.grid_unit, "y": start_y - project.grid_unit}
    Xi, Yi = start_x, start_y # - project.grid_unit
    r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/templates/{switch_template_id}", data=json.dumps(payload), auth=(server.user, server.password))
    r.raise_for_status()
    switch_node_id = r.json()["node_id"]
    time.sleep(0.3)

    # create device grid
    devices_node_id = []
    dy = 0
    for i in range(num_devices):
        payload = {"x": start_x + (i%devices_per_row)*project.grid_unit, "y": start_y + dy}
        r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/templates/{device_template_id}", data=json.dumps(payload), auth=(server.user, server.password))
        r.raise_for_status()
        devices_node_id.append(r.json()["node_id"])
        if i%devices_per_row == devices_per_row-1:
            dy += project.grid_unit
        time.sleep(0.3)
    assert len(devices_node_id) == num_devices
    Xf, Yf = start_x + (devices_per_row-1)*project.grid_unit, start_y+dy
    # link devices to the switch
    devices_link_id = []
    for i, dev in enumerate(devices_node_id, start=1):
        # [!] for "Ethernet switch" (builtin) "adapter_number": 0, "port_number": i
        # ^_  https://docs.gns3.com/docs/using-gns3/beginners/switching-and-gns3/
        # [!] for Open vSwitch "adapter_number": i, "port_number": 0
        # for i in $(seq 16 63); do ovs-vsctl add-port br0 eth$i; done
        payload = {"nodes": [{"adapter_number": 0, "node_id": dev, "port_number": 0},
                             {"adapter_number": i, "node_id": switch_node_id, "port_number": 0}]}
        r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/links", data=json.dumps(payload), auth=(server.user, server.password))
        r.raise_for_status()
        devices_link_id.append(r.json()["link_id"])
        time.sleep(0.3)
    assert len(devices_link_id) == num_devices
    
    # change device configuration
    netmask = "255.255.0.0"
    for i, dev in enumerate(devices_node_id, start=0):
        payload = get_static_interface_config_file("eth0", start_ip+i, netmask, "192.168.0.1")
        r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/nodes/{dev}/files/etc/network/interfaces", data=payload, auth=(server.user, server.password))
        r.raise_for_status()
        print("Configured ", dev, " ", r.status_code)
        time.sleep(0.3)

    # decoration
    payload = {"x": start_x + (int(devices_per_row/2)+2)*project.grid_unit, "y": start_y - project.grid_unit,
               "svg": f"<svg><text>{start_ip}\n{start_ip+num_devices-1}\n{netmask}</text></svg>"}
    r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/drawings", data=json.dumps(payload), auth=(server.user, server.password))
    r.raise_for_status()
    
    return {"switch_node_id": switch_node_id, "devices_node_id": devices_node_id, "devices_link_id": devices_link_id}, (Xi, Yi, Xf, Yf)


def start_capture(server, project, link_ids):
    for link in link_ids:
        r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/links/{link}/start_capture", data={}, auth=(server.user, server.password))
        r.raise_for_status()
        result = r.json()
        print(f"Capturing {result['capturing']}, {result['capture_file_name']}")
        time.sleep(0.3)


def stop_capture(server, project, link_ids):
    for link in link_ids:
        r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/links/{link}/stop_capture", data={}, auth=(server.user, server.password))
        r.raise_for_status()
        result = r.json()
        print(f"Capturing {result['capturing']}, {result['capture_file_name']}")
        time.sleep(0.3)


def start_all_switches(server: Server, project: Project, switches_pattern : Pattern=re.compile("openvswitch.*", re.IGNORECASE)) -> None:
    switches = get_nodes_id_by_name_regexp(server, project, switches_pattern)
    if switches:
        print(f"found {len(switches)} switches")
        for sw in switches:
            print(f"Starting {sw.name}... ", end="", flush=True)
            start_node(server, project, sw.id)
            print("OK")
            time.sleep(0.3)


def stop_all_switches(server: Server, project: Project, switches_pattern : Pattern=re.compile("openvswitch.*", re.IGNORECASE)) -> None:
    switches = get_nodes_id_by_name_regexp(server, project, switches_pattern)
    if switches:
        print(f"found {len(switches)} switches")
        for sw in switches:
            print(f"Stopping {sw.name}... ", end="", flush=True)
            stop_node(server, project, sw.id)
            print("OK")
            time.sleep(0.3)


def start_capture_all_iot_links(server, project, switches_pattern: Pattern=re.compile("openvswitch.*", re.IGNORECASE), iot_pattern: Pattern=re.compile("mqtt-device.*|coap-device.*", re.IGNORECASE)) -> None:
    switches = get_nodes_id_by_name_regexp(server, project, switches_pattern)
    if switches:
        print(f"found {len(switches)} switches")
        for sw in switches:
            print(f"Finding links in switch {sw.name}... ", end="", flush=True)
            links = get_links_id_from_node_connected_to_name_regexp(server, project, sw.id, iot_pattern)
            if links:
                print(f"{len(links)} found")
                for lk in links:
                    print(f"\t Starting capture in link {lk.name}... ", end="", flush=True)
                    start_capture(server, project, [lk.id])
                    print("OK")
            else:
                print("0 links, skipping.")
        time.sleep(0.3)


def stop_capture_all_iot_links(server, project, switches_pattern: Pattern=re.compile("openvswitch.*", re.IGNORECASE), iot_pattern: Pattern=re.compile("mqtt-device.*|coap-device.*", re.IGNORECASE)) -> None:
    switches = get_nodes_id_by_name_regexp(server, project, switches_pattern)
    if switches:
        print(f"found {len(switches)} switches")
        for sw in switches:
            print(f"Finding links in switch {sw.name}... ", end="", flush=True)
            links = get_links_id_from_node_connected_to_name_regexp(server, project, sw.id, iot_pattern)
            if links:
                print(f"{len(links)} found")
                for lk in links:
                    print(f"\t Stopping capture in link {lk.name}... ", end="", flush=True)
                    stop_capture(server, project, [lk.id])
                    print("OK")
            else:
                print("0 links, skipping.")
        time.sleep(0.3)


check_resources()

server = Server(*read_local_gns3_config())

req_version = requests.get(f"http://{server.addr}:{server.port}/v2/version", auth=(server.user, server.password))
req_version.raise_for_status()
print(req_version.json())

req_projects = requests.get(f"http://{server.addr}:{server.port}/v2/projects", auth=(server.user, server.password))
req_projects.raise_for_status()
projects: List[Dict[str, Any]] = req_projects.json()
print(len(projects), " projects")
if projects:
    for p in projects:
        print(f"Name='{p['name']}', ID='{p['project_id']}'")

filtered_projects = list(filter(lambda x: x["name"]==PROJECT_NAME, projects))
if filtered_projects:
    p = filtered_projects[0]
    project = Project(name=p["name"], id=p["project_id"], grid_unit=int(p["grid_size"]*1.4))
    print(f"Project {PROJECT_NAME} exists. ", project)
else:
    # create the project
    # http://api.gns3.net/en/2.2/api/v2/controller/project/projects.html
    payload = {"name": PROJECT_NAME, "show_grid": True, "scene_height": 2000, "scene_width": 4000}
    r = requests.post(f"http://{server.addr}:{server.port}/v2/projects", data=json.dumps(payload), auth=(server.user, server.password))
    r.raise_for_status()
    p = r.json()
    project = Project(name=p["name"], id=p["project_id"], grid_unit=int(p["grid_size"]*1.4))
    assert project.name == PROJECT_NAME
    print("Created project ", project)

# open project if closed
if p["status"] == "closed":
    r = requests.post(f"http://{server.addr}:{server.port}/v2/projects/{project.id}/open", data={}, auth=(server.user, server.password))
    r.raise_for_status()
    assert r.json()["status"] == "opened"

# Por ahora crear los templates en GNS3 GUI
# get templates
r = requests.get(f"http://{server.addr}:{server.port}/v2/templates", auth=(server.user, server.password))
r.raise_for_status()
templates = r.json()

# get template ids
# "Open vSwitch 64": ehlers/openvswitch
# "Open vSwitch": default appliance
switch_64_template_id = template_id_from_name(templates, "Open vSwitch 64")
assert switch_64_template_id
mqtt_device_t1_template_id = template_id_from_name(templates, "mqtt-device-t1")
assert mqtt_device_t1_template_id
mqtt_device_t2_template_id = template_id_from_name(templates, "mqtt-device-t2")
assert mqtt_device_t2_template_id
coap_device_t1_template_id = template_id_from_name(templates, "coap-device-t1")
assert coap_device_t1_template_id

# -1900, -400

cluster_mqtt1, coord = create_cluster_of_devices(server, project, 50, -1900, -300, switch_64_template_id, mqtt_device_t1_template_id, ipaddress.IPv4Address("192.168.10.1"))
cluster_mqtt2, coord = create_cluster_of_devices(server, project, 50, coord[2]+2*project.grid_unit, coord[1], switch_64_template_id, mqtt_device_t2_template_id, ipaddress.IPv4Address("192.168.20.1"))
cluster_coap1, coord = create_cluster_of_devices(server, project, 50, coord[2]+2*project.grid_unit, coord[1], switch_64_template_id, coap_device_t1_template_id, ipaddress.IPv4Address("192.168.30.1"))

start_capture(server, project, cluster_mqtt1["devices_link_id"])
start_capture(server, project, cluster_mqtt2["devices_link_id"])
start_capture(server, project, cluster_coap1["devices_link_id"])

# get_nodes_id_by_name_regexp(server, project, re.compile("openvswitch.*", re.IGNORECASE))
# get_links_id_from_node_connected_to_name_regexp(server, project, '4a2a6591-7b87-4c8d-948f-50eed4cd2c61', re.compile("mqtt-device-t1.*", re.IGNORECASE))

# --------------------------------------------
# start_all_switches(server, project)
# click play button in GNS3 |>
# check coap cloud
# start_capture_all_iot_links(server, project)
# stop_capture_all_iot_links(server, project)